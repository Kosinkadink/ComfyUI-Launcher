name: Version Bump PR

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: Branch to update
        required: true
        type: string
        default: main
      bump:
        description: Which segment to bump
        required: true
        type: choice
        default: patch
        options:
          - patch
          - minor
          - major
      push_tag:
        description: Create and push a matching v<version> tag for the PR commit
        required: true
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: version-bump-${{ github.event.inputs.target_branch }}
  cancel-in-progress: false

jobs:
  bump:
    runs-on: ubuntu-latest
    name: Bump package.json Version

    steps:
      - name: Checkout target branch
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ inputs.target_branch }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 22

      - name: Configure Git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Bump package.json version
        id: bump
        env:
          BUMP_TYPE: ${{ inputs.bump }}
        run: |
          set -euo pipefail

          OLD_VERSION="$(node -p "require('./package.json').version")"
          NEW_VERSION="$(node <<'NODE'
          const fs = require('node:fs')

          const bumpType = process.env.BUMP_TYPE
          const pkgPath = 'package.json'
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'))
          const match = String(pkg.version).match(/^(\d+)\.(\d+)\.(\d+)$/)

          if (!match) {
            throw new Error(`Unsupported version format: ${pkg.version}`)
          }

          let major = Number(match[1])
          let minor = Number(match[2])
          let patch = Number(match[3])

          if (bumpType === 'major') {
            major += 1
            minor = 0
            patch = 0
          } else if (bumpType === 'minor') {
            minor += 1
            patch = 0
          } else if (bumpType === 'patch') {
            patch += 1
          } else {
            throw new Error(`Unsupported bump type: ${bumpType}`)
          }

          const nextVersion = `${major}.${minor}.${patch}`
          pkg.version = nextVersion
          fs.writeFileSync(pkgPath, `${JSON.stringify(pkg, null, 2)}\n`)
          process.stdout.write(nextVersion)
          NODE
          )"

          echo "old_version=${OLD_VERSION}" >> "$GITHUB_OUTPUT"
          echo "new_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Bumped version ${OLD_VERSION} -> ${NEW_VERSION}"

      - name: Prepare PR metadata
        id: prepare
        env:
          TARGET_BRANCH: ${{ inputs.target_branch }}
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
        run: |
          set -euo pipefail

          SAFE_TARGET_BRANCH="$(echo "${TARGET_BRANCH}" | tr '/ ' '--' | tr -cd '[:alnum:]._-')"
          PR_BRANCH="automation/version-bump/${SAFE_TARGET_BRANCH}/v${NEW_VERSION}"

          echo "pr_branch=${PR_BRANCH}" >> "$GITHUB_OUTPUT"

      - name: Commit and push version bump branch
        id: branch
        env:
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
          PR_BRANCH: ${{ steps.prepare.outputs.pr_branch }}
        run: |
          set -euo pipefail

          if git diff --quiet -- package.json; then
            echo "No changes detected in package.json."
            exit 1
          fi

          git checkout -B "${PR_BRANCH}"
          git add package.json
          git commit -m "chore: bump version to ${NEW_VERSION}"
          git push --force-with-lease origin "${PR_BRANCH}"

          echo "head_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Create or update version bump pull request
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
          PR_BRANCH: ${{ steps.prepare.outputs.pr_branch }}
          OLD_VERSION: ${{ steps.bump.outputs.old_version }}
          NEW_VERSION: ${{ steps.bump.outputs.new_version }}
          BUMP_TYPE: ${{ inputs.bump }}
          PUSH_TAG: ${{ inputs.push_tag }}
        run: |
          set -euo pipefail

          BODY_FILE="$(mktemp)"
          cat > "${BODY_FILE}" <<EOF
          ## Summary
          - bump \`package.json\` version from \`${OLD_VERSION}\` to \`${NEW_VERSION}\`
          - generated by \`Version Bump PR\` workflow

          ## Details
          - target branch: \`${TARGET_BRANCH}\`
          - bump type: \`${BUMP_TYPE}\`
          - requested tag creation: \`${PUSH_TAG}\`
          EOF

          EXISTING_PR_NUMBER="$(gh pr list \
            --repo "${GITHUB_REPOSITORY}" \
            --base "${TARGET_BRANCH}" \
            --head "${PR_BRANCH}" \
            --state open \
            --json number \
            --jq '.[0].number // ""')"

          if [ -n "${EXISTING_PR_NUMBER}" ]; then
            gh pr edit "${EXISTING_PR_NUMBER}" \
              --repo "${GITHUB_REPOSITORY}" \
              --title "chore: bump version to ${NEW_VERSION}" \
              --body-file "${BODY_FILE}"

            PR_URL="$(gh pr view "${EXISTING_PR_NUMBER}" \
              --repo "${GITHUB_REPOSITORY}" \
              --json url \
              --jq '.url')"
          else
            PR_URL="$(gh pr create \
              --repo "${GITHUB_REPOSITORY}" \
              --base "${TARGET_BRANCH}" \
              --head "${PR_BRANCH}" \
              --title "chore: bump version to ${NEW_VERSION}" \
              --body-file "${BODY_FILE}")"
          fi

          echo "pull_request_url=${PR_URL}" >> "$GITHUB_OUTPUT"

      - name: Create and push version tag
        if: ${{ inputs.push_tag && steps.branch.outputs.head_sha != '' }}
        env:
          PR_HEAD_SHA: ${{ steps.branch.outputs.head_sha }}
        run: |
          set -euo pipefail

          TAG="v${{ steps.bump.outputs.new_version }}"

          if git ls-remote --exit-code --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists on origin."
            exit 1
          fi

          git tag "${TAG}" "${PR_HEAD_SHA}"
          git push origin "${TAG}"

      - name: Print results
        run: |
          echo "pull_request_url=${{ steps.pr.outputs.pull_request_url }}"
          if [ "${{ inputs.push_tag }}" = "true" ]; then
            echo "tag=v${{ steps.bump.outputs.new_version }}"
          fi
