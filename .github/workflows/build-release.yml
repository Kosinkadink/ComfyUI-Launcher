name: ToDesktop Build & Release

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    name: ToDesktop Build
    env:
      TODESKTOP_ACCESS_TOKEN: ${{ secrets.TODESKTOP_ACCESS_TOKEN }}
      TODESKTOP_EMAIL: ${{ secrets.TODESKTOP_EMAIL }}
    outputs:
      build_id: ${{ steps.extract.outputs.build_id }}
      mac_url: ${{ steps.extract.outputs.mac_url }}
      windows_url: ${{ steps.extract.outputs.windows_url }}
      linux_url: ${{ steps.extract.outputs.linux_url }}
      build_status: ${{ steps.extract.outputs.build_status }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 22

      - name: Validate ToDesktop credentials
        run: |
          if [ -z "$TODESKTOP_EMAIL" ] || [ -z "$TODESKTOP_ACCESS_TOKEN" ]; then
            echo "TODESKTOP_EMAIL and TODESKTOP_ACCESS_TOKEN must be set in repository secrets."
            exit 1
          fi

      - name: Ensure tag matches package.json version
        if: startsWith(github.ref, 'refs/tags/v')
        shell: bash
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          PKG_VERSION="$(node -p "require('./package.json').version")"
          if [ "$TAG_VERSION" != "$PKG_VERSION" ]; then
            echo "Tag version ($TAG_VERSION) does not match package.json version ($PKG_VERSION)."
            exit 1
          fi

      - name: Install ToDesktop CLI
        run: npm install --location=global @todesktop/cli@1.22.0

      - name: Build with ToDesktop
        run: todesktop build --config=todesktop.json --ephemeral

      - name: Fetch latest ToDesktop build metadata
        run: todesktop builds --config=todesktop.json --format=json --count=1 --exit > todesktop-builds.json

      - name: Extract build details
        id: extract
        shell: bash
        run: |
          node <<'NODE'
          const fs = require('node:fs')
          const raw = fs.readFileSync('todesktop-builds.json', 'utf8')
          const start = raw.indexOf('[')
          const end = raw.lastIndexOf(']')
          const jsonText = start !== -1 && end !== -1 && end > start ? raw.slice(start, end + 1) : raw

          let builds
          try {
            builds = JSON.parse(jsonText)
          } catch (err) {
            console.error('Failed to parse ToDesktop builds JSON output')
            console.error(raw.slice(0, 1000))
            throw err
          }

          if (!Array.isArray(builds) || builds.length === 0) {
            throw new Error('No builds found in ToDesktop builds output')
          }

          const build = builds[0]
          const safeUrl = (value) => (typeof value === 'string' ? value : '')
          const macUrl = safeUrl(build?.mac?.standardDownloadUrl)
          const windowsUrl = safeUrl(build?.windows?.standardDownloadUrl)
          const linuxUrl = safeUrl(build?.linux?.standardDownloadUrl)
          const universalUrl = safeUrl(build?.standardUniversalDownloadUrl)
          const status = build?.status || 'unknown'
          const buildId = build?.id || ''

          if (!buildId) {
            throw new Error('Build ID missing from ToDesktop build output')
          }

          const titleCase = (value) =>
            String(value)
              .replace(/[-_]/g, ' ')
              .replace(/\b\w/g, (m) => m.toUpperCase())

          const normalizeFormatName = (value) => {
            if (value === 'appImage') return 'AppImage'
            return titleCase(value)
          }

          const normalizeArchName = (value) => {
            const lowered = String(value).toLowerCase()
            if (lowered === 'x64') return 'x64'
            if (lowered === 'arm64') return 'arm64'
            if (lowered === 'ia32') return 'ia32'
            if (lowered === 'universal') return 'universal'
            return titleCase(value)
          }

          const collectArtifacts = (platformName, platformData) => {
            const rows = []
            const artifactDownloads = platformData?.artifactDownloads
            if (!artifactDownloads || typeof artifactDownloads !== 'object') return rows

            for (const [formatKey, formatValue] of Object.entries(artifactDownloads)) {
              if (!formatValue || typeof formatValue !== 'object') continue

              const directUrl = safeUrl(formatValue.standardUrl || formatValue.url)
              if (directUrl) {
                rows.push({
                  platform: platformName,
                  format: normalizeFormatName(formatKey),
                  arch: 'n/a',
                  size: Number.isFinite(formatValue.size) ? `${formatValue.size} bytes` : 'n/a',
                  url: directUrl
                })
                continue
              }

              for (const [archKey, archValue] of Object.entries(formatValue)) {
                if (!archValue || typeof archValue !== 'object') continue
                const url = safeUrl(archValue.standardUrl || archValue.url)
                if (!url) continue

                rows.push({
                  platform: platformName,
                  format: normalizeFormatName(formatKey),
                  arch: normalizeArchName(archKey),
                  size: Number.isFinite(archValue.size) ? `${archValue.size} bytes` : 'n/a',
                  url
                })
              }
            }

            return rows.sort((a, b) => {
              if (a.platform !== b.platform) return a.platform.localeCompare(b.platform)
              if (a.format !== b.format) return a.format.localeCompare(b.format)
              return a.arch.localeCompare(b.arch)
            })
          }

          const assetRows = [
            ...collectArtifacts('macOS', build?.mac),
            ...collectArtifacts('Windows', build?.windows),
            ...collectArtifacts('Linux', build?.linux)
          ]

          const todesktopConfig = JSON.parse(fs.readFileSync('todesktop.json', 'utf8'))
          const appId = todesktopConfig.id
          const buildPageUrl = `https://app.todesktop.com/apps/${appId}/builds/${buildId}`

          fs.writeFileSync(
            'release-assets.json',
            JSON.stringify(
              {
                buildId,
                status,
                buildPageUrl,
                universalUrl,
                platformPages: {
                  macOS: macUrl || null,
                  windows: windowsUrl || null,
                  linux: linuxUrl || null
                },
                assets: assetRows
              },
              null,
              2
            )
          )

          const output = process.env.GITHUB_OUTPUT
          if (!output) throw new Error('GITHUB_OUTPUT not set')
          fs.appendFileSync(output, `build_id=${buildId}\n`)
          fs.appendFileSync(output, `build_status=${status}\n`)
          fs.appendFileSync(output, `mac_url=${macUrl}\n`)
          fs.appendFileSync(output, `windows_url=${windowsUrl}\n`)
          fs.appendFileSync(output, `linux_url=${linuxUrl}\n`)

          if (status !== 'succeeded') {
            throw new Error(`ToDesktop build did not succeed (status=${status})`)
          }
          NODE

      - name: Upload release metadata artifact
        uses: actions/upload-artifact@v7
        with:
          name: todesktop-release-assets
          path: release-assets.json

  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    name: Publish Release

    steps:
<<<<<<< HEAD
      - name: Download all artifacts
        uses: actions/download-artifact@v8
        with:
          path: artifacts
          merge-multiple: true
=======
      - name: Create GitHub Release (gh CLI)
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
>>>>>>> origin/main

          tag="${GITHUB_REF_NAME}"

          if gh release view "${tag}" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            echo "Release for ${tag} already exists."
            exit 0
          fi

          gh release create "${tag}" \
            --repo "${GITHUB_REPOSITORY}" \
            --draft \
            --generate-notes

          echo "Created draft release for ${tag}."
