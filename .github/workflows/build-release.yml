name: ToDesktop Build & Release

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"

permissions:
  contents: write

concurrency:
  group: build-release-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  build:
    if: >
      startsWith(github.ref, 'refs/tags/v') &&
      (github.event_name == 'workflow_dispatch' || github.actor != 'github-actions[bot]')
    runs-on: ubuntu-latest
    name: ToDesktop Build
    env:
      TODESKTOP_ACCESS_TOKEN: ${{ secrets.TODESKTOP_ACCESS_TOKEN }}
      TODESKTOP_EMAIL: ${{ secrets.TODESKTOP_EMAIL }}
    outputs:
      build_id: ${{ steps.extract.outputs.build_id }}
      mac_url: ${{ steps.extract.outputs.mac_url }}
      windows_url: ${{ steps.extract.outputs.windows_url }}
      linux_url: ${{ steps.extract.outputs.linux_url }}
      build_status: ${{ steps.extract.outputs.build_status }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 22
          cache: pnpm

      - name: Validate ToDesktop credentials
        run: |
          if [ -z "$TODESKTOP_EMAIL" ] || [ -z "$TODESKTOP_ACCESS_TOKEN" ]; then
            echo "TODESKTOP_EMAIL and TODESKTOP_ACCESS_TOKEN must be set in repository secrets."
            exit 1
          fi

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build app
        run: pnpm run build

      - name: Ensure tag matches package.json version
        if: startsWith(github.ref, 'refs/tags/v')
        shell: bash
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          PKG_VERSION="$(node -p "require('./package.json').version")"
          if [ "$TAG_VERSION" != "$PKG_VERSION" ]; then
            echo "Tag version ($TAG_VERSION) does not match package.json version ($PKG_VERSION)."
            exit 1
          fi

      - name: Install ToDesktop CLI
        run: npm install --location=global @todesktop/cli@1.22.0

      - name: Build with ToDesktop
        shell: bash
        run: |
          set -euo pipefail
          todesktop build --config=todesktop.json --ephemeral | tee todesktop-build.log

      - name: Extract ToDesktop build ID
        id: build_id
        shell: bash
        run: |
          node <<'NODE'
          const fs = require('node:fs')

          const log = fs.readFileSync('todesktop-build.log', 'utf8')
          const matches = [
            ...log.matchAll(
              /https?:\/\/(?:app\.todesktop\.com\/apps|dl\.todesktop\.com)\/[^/\s]+\/builds\/([A-Za-z0-9_-]+)/g
            )
          ]
          const buildIds = [...new Set(matches.map((match) => match[1]).filter(Boolean))]

          if (buildIds.length === 0) {
            throw new Error('Could not extract a ToDesktop build ID from CLI output.')
          }
          if (buildIds.length > 1) {
            throw new Error(`Multiple build IDs found in CLI output (${buildIds.join(', ')}).`)
          }

          const output = process.env.GITHUB_OUTPUT
          if (!output) throw new Error('GITHUB_OUTPUT not set')
          fs.appendFileSync(output, `build_id=${buildIds[0]}\n`)
          NODE

      - name: Fetch ToDesktop build metadata by ID
        env:
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: todesktop builds "${BUILD_ID}" --config=todesktop.json --format=json --exit > todesktop-build.json

      - name: Extract build details
        id: extract
        shell: bash
        run: |
          node <<'NODE'
          const fs = require('node:fs')

          const parseBuildOutput = (filePath) => {
            const raw = fs.readFileSync(filePath, 'utf8')
            const start = raw.indexOf('[')
            const end = raw.lastIndexOf(']')
            const jsonText =
              start !== -1 && end !== -1 && end > start
                ? raw.slice(start, end + 1)
                : raw.slice(raw.indexOf('{'), raw.lastIndexOf('}') + 1)

            let parsed
            try {
              parsed = JSON.parse(jsonText)
            } catch (err) {
              console.error(`Failed to parse ToDesktop build JSON output from ${filePath}`)
              console.error(raw.slice(0, 1000))
              throw err
            }

            if (Array.isArray(parsed)) {
              if (parsed.length === 0) {
                throw new Error(`No builds returned in ${filePath}`)
              }
              return parsed[0]
            }

            if (parsed && typeof parsed === 'object') {
              return parsed
            }

            throw new Error(`Unexpected ToDesktop build output shape in ${filePath}`)
          }

          const expectedBuildId = process.env.EXPECTED_BUILD_ID || ''
          const build = parseBuildOutput('todesktop-build.json')
          const safeUrl = (value) => (typeof value === 'string' ? value : '')
          const macUrl = safeUrl(build?.mac?.standardDownloadUrl)
          const windowsUrl = safeUrl(build?.windows?.standardDownloadUrl)
          const linuxUrl = safeUrl(build?.linux?.standardDownloadUrl)
          const universalUrl = safeUrl(build?.standardUniversalDownloadUrl)
          const status = build?.status || 'unknown'
          const buildId = build?.id || ''

          if (!buildId) {
            throw new Error('Build ID missing from ToDesktop build output')
          }
          if (expectedBuildId && String(buildId) !== expectedBuildId) {
            throw new Error(`Build ID mismatch. Expected ${expectedBuildId}, received ${buildId}`)
          }

          const titleCase = (value) =>
            String(value)
              .replace(/[-_]/g, ' ')
              .replace(/\b\w/g, (m) => m.toUpperCase())

          const normalizeFormatName = (value) => {
            if (value === 'appImage') return 'AppImage'
            return titleCase(value)
          }

          const normalizeArchName = (value) => {
            const lowered = String(value).toLowerCase()
            if (lowered === 'x64') return 'x64'
            if (lowered === 'arm64') return 'arm64'
            if (lowered === 'ia32') return 'ia32'
            if (lowered === 'universal') return 'universal'
            return titleCase(value)
          }

          const collectArtifacts = (platformName, platformData) => {
            const rows = []
            const artifactDownloads = platformData?.artifactDownloads
            if (!artifactDownloads || typeof artifactDownloads !== 'object') return rows

            for (const [formatKey, formatValue] of Object.entries(artifactDownloads)) {
              if (!formatValue || typeof formatValue !== 'object') continue

              const directUrl = safeUrl(formatValue.standardUrl || formatValue.url)
              if (directUrl) {
                rows.push({
                  platform: platformName,
                  format: normalizeFormatName(formatKey),
                  arch: 'n/a',
                  size: Number.isFinite(formatValue.size) ? `${formatValue.size} bytes` : 'n/a',
                  url: directUrl
                })
                continue
              }

              for (const [archKey, archValue] of Object.entries(formatValue)) {
                if (!archValue || typeof archValue !== 'object') continue
                const url = safeUrl(archValue.standardUrl || archValue.url)
                if (!url) continue

                rows.push({
                  platform: platformName,
                  format: normalizeFormatName(formatKey),
                  arch: normalizeArchName(archKey),
                  size: Number.isFinite(archValue.size) ? `${archValue.size} bytes` : 'n/a',
                  url
                })
              }
            }

            return rows.sort((a, b) => {
              if (a.platform !== b.platform) return a.platform.localeCompare(b.platform)
              if (a.format !== b.format) return a.format.localeCompare(b.format)
              return a.arch.localeCompare(b.arch)
            })
          }

          const assetRows = [
            ...collectArtifacts('macOS', build?.mac),
            ...collectArtifacts('Windows', build?.windows),
            ...collectArtifacts('Linux', build?.linux)
          ]

          const todesktopConfig = JSON.parse(fs.readFileSync('todesktop.json', 'utf8'))
          const appId = todesktopConfig.id
          const buildPageUrl = `https://app.todesktop.com/apps/${appId}/builds/${buildId}`

          fs.writeFileSync(
            'release-assets.json',
            JSON.stringify(
              {
                buildId,
                status,
                buildPageUrl,
                universalUrl,
                platformPages: {
                  macOS: macUrl || null,
                  windows: windowsUrl || null,
                  linux: linuxUrl || null
                },
                assets: assetRows
              },
              null,
              2
            )
          )

          const output = process.env.GITHUB_OUTPUT
          if (!output) throw new Error('GITHUB_OUTPUT not set')
          fs.appendFileSync(output, `build_id=${buildId}\n`)
          fs.appendFileSync(output, `build_status=${status}\n`)
          fs.appendFileSync(output, `mac_url=${macUrl}\n`)
          fs.appendFileSync(output, `windows_url=${windowsUrl}\n`)
          fs.appendFileSync(output, `linux_url=${linuxUrl}\n`)

          if (status !== 'succeeded') {
            throw new Error(`ToDesktop build did not succeed (status=${status})`)
          }
          NODE
        env:
          EXPECTED_BUILD_ID: ${{ steps.build_id.outputs.build_id }}

      - name: Upload release metadata artifact
        uses: actions/upload-artifact@v7
        with:
          name: todesktop-release-assets
          path: release-assets.json

  release:
    needs: build
    if: >
      startsWith(github.ref, 'refs/tags/v') &&
      (github.event_name == 'workflow_dispatch' || github.actor != 'github-actions[bot]')
    runs-on: ubuntu-latest
    name: Publish Release

    steps:
      - name: Create GitHub Release (gh CLI)
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          tag="${GITHUB_REF_NAME}"

          if gh release view "${tag}" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            echo "Release for ${tag} already exists."
            exit 0
          fi

          gh release create "${tag}" \
            --repo "${GITHUB_REPOSITORY}" \
            --draft \
            --generate-notes

          echo "Created draft release for ${tag}."
